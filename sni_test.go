package quic

import (
	"context"
	"crypto/rand"
	"crypto/tls"
	"io"
	mrand "math/rand/v2"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var clientHello = []byte{0x1, 0x0, 0x1, 0x8, 0x3, 0x3, 0x60, 0x79, 0x84, 0x76, 0x5c, 0x3c, 0x44, 0x83, 0xd8, 0x84, 0x40, 0xf8, 0x93, 0x8c, 0x37, 0xcc, 0xc, 0x6e, 0xf7, 0xea, 0x73, 0xd, 0xae, 0x89, 0xc4, 0xbd, 0x90, 0xdd, 0x79, 0x55, 0x86, 0xfc, 0x0, 0x0, 0x6, 0x13, 0x1, 0x13, 0x2, 0x13, 0x3, 0x1, 0x0, 0x0, 0xd9, 0x0, 0x0, 0x0, 0xf, 0x0, 0xd, 0x0, 0x0, 0xa, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x0, 0xb, 0x0, 0x2, 0x1, 0x0, 0xff, 0x1, 0x0, 0x1, 0x0, 0x0, 0x17, 0x0, 0x0, 0x0, 0x12, 0x0, 0x0, 0x0, 0x39, 0x0, 0x40, 0x4a, 0x47, 0x8, 0x9d, 0x1f, 0xdd, 0x96, 0x99, 0x5, 0xfb, 0xe8, 0x5, 0x4, 0x80, 0x8, 0x0, 0x0, 0x6, 0x4, 0x80, 0x8, 0x0, 0x0, 0x7, 0x4, 0x80, 0x8, 0x0, 0x0, 0x4, 0x4, 0x80, 0xc, 0x0, 0x0, 0x8, 0x1, 0x0, 0x9, 0x2, 0x40, 0x64, 0x1, 0x4, 0x80, 0x0, 0x75, 0x30, 0x3, 0x2, 0x45, 0xac, 0xb, 0x1, 0x1a, 0xe, 0x1, 0x4, 0xf, 0x4, 0x1c, 0x83, 0xfa, 0xfb, 0x0, 0x5, 0x0, 0x5, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x0, 0xa, 0x0, 0x8, 0x0, 0x1d, 0x0, 0x17, 0x0, 0x18, 0x0, 0x19, 0x0, 0xd, 0x0, 0x1a, 0x0, 0x18, 0x8, 0x4, 0x4, 0x3, 0x8, 0x7, 0x8, 0x5, 0x8, 0x6, 0x4, 0x1, 0x5, 0x1, 0x6, 0x1, 0x5, 0x3, 0x6, 0x3, 0x2, 0x1, 0x2, 0x3, 0x0, 0x10, 0x0, 0x5, 0x0, 0x3, 0x2, 0x68, 0x33, 0x0, 0x2b, 0x0, 0x3, 0x2, 0x3, 0x4, 0x0, 0x33, 0x0, 0x26, 0x0, 0x24, 0x0, 0x1d, 0x0, 0x20, 0x45, 0x64, 0x16, 0xb7, 0xbb, 0x79, 0x1b, 0xce, 0x22, 0xb9, 0x57, 0x8b, 0xd0, 0x54, 0xd8, 0x32, 0x50, 0x5d, 0x1e, 0xa9, 0x9a, 0xba, 0xc5, 0xa7, 0xd3, 0x22, 0x99, 0xbf, 0x8f, 0x57, 0x68, 0x3a}

func TestFindSNIStatic(t *testing.T) {
	sniPos, sniLen, echPos, err := findSNIAndECH(clientHello)
	require.NoError(t, err)
	require.NotZero(t, sniPos)
	require.Equal(t, -1, echPos)
	require.Equal(t, "google.com", string(clientHello[sniPos:sniPos+sniLen]))

	for i := range clientHello {
		_, _, _, err := findSNIAndECH(clientHello[:i])
		require.ErrorIs(t, err, io.ErrUnexpectedEOF)
	}
}

// findSNI is never run with attacker-controlled inputs (other than the session ticket),
// so this is not a high-value target to begin with,
// and doesn't need to be run in ClusterFuzz.
// It's still useful to find potential corner cases in the parser.
func FuzzFindSNI(f *testing.F) {
	f.Add(clientHello)

	f.Fuzz(func(t *testing.T, data []byte) {
		_, _, _, _ = findSNIAndECH(data)

	})
}

func TestFindSNI(t *testing.T) {
	t.Run("without SNI", func(t *testing.T) {
		testFindSNI(t, "")
	})
	t.Run("without subdomain", func(t *testing.T) {
		testFindSNI(t, "quic-go.net")
	})
	t.Run("with subdomain", func(t *testing.T) {
		testFindSNI(t, "sub.do.ma.in.quic-go.net")
	})
}

func testFindSNI(t *testing.T, serverName string) {
	c := tls.QUICClient(&tls.QUICConfig{
		TLSConfig: &tls.Config{
			ServerName:         serverName,
			MinVersion:         tls.VersionTLS13,
			InsecureSkipVerify: serverName == "",
		},
	})
	b := make([]byte, mrand.IntN(200))
	rand.Read(b)
	c.SetTransportParameters(b)
	require.NoError(t, c.Start(context.Background()))

	ev := c.NextEvent()
	require.Equal(t, tls.QUICWriteData, ev.Kind)
	sniPos, sniLen, echPos, err := findSNIAndECH(ev.Data)
	require.NoError(t, err)
	assert.Equal(t, -1, echPos)
	if serverName == "" {
		require.Equal(t, -1, sniPos)
		return
	}
	assert.Equal(t, len(serverName), sniLen)
	require.NotEqual(t, -1, sniPos)
	require.Equal(t, serverName, string(ev.Data[sniPos:sniPos+sniLen]))
}
